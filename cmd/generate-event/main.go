package main

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"go/format"
	"io/fs"
	"log/slog"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/Masterminds/sprig/v3"
	"github.com/spf13/pflag"

	"github.com/FuturFusion/migration-manager/internal/logger"
)

//go:embed tmpl
var templateFS embed.FS

const generatedByPreamble = `// Code generated by generate-event; DO NOT EDIT.

`

// FileType represents a specific type of file.
type FileType string

const (
	FileTypeGo  FileType = "go"
	FileTypeTS  FileType = "ts"
	FileTypeTSX FileType = "tsx"
)

func main() {
	ctx := context.Background()

	flagConfigFile := pflag.String("config", "generate-event.yaml", "filename of the configfile")
	flagLogDebug := pflag.BoolP("debug", "d", false, "Show all debug messages")
	flagLogVerbose := pflag.BoolP("verbose", "v", false, "Show all information messages")
	flagLogTargetDir := pflag.StringP("target", "t", "", "Target directory")

	pflag.Parse()

	if *flagLogTargetDir == "" {
		die(errors.New("Specify target directory"))
	}

	_, err := logger.InitLogger("", *flagLogVerbose, *flagLogDebug)
	die(err)

	slog.DebugContext(ctx, "config file", slog.String("filename", *flagConfigFile))

	var cfg Config
	err = cfg.LoadConfig(*flagConfigFile)
	die(err)

	allEntities := make(map[string]*Entity, len(cfg))

	funcsMap := sprig.FuncMap()
	funcsMap["pascalcase"] = PascalCase
	funcsMap["camelcase"] = CamelCase
	funcsMap["kebabcase"] = KebabCase
	funcsMap["titlecase"] = TitleCase
	funcsMap["words"] = Words
	funcsMap["eval"] = func(tmplText string, data any) (string, error) {
		t, err := template.New("eval").Funcs(funcsMap).Parse(tmplText)
		if err != nil {
			return "", err
		}

		var buf bytes.Buffer
		err = t.Execute(&buf, data)
		if err != nil {
			return "", err
		}

		return buf.String(), nil
	}

	t := template.New("")
	t = t.Funcs(funcsMap)
	t, err = t.ParseFS(templateFS, "tmpl/*.gotmpl")
	die(err)

	for _, entity := range cfg {
		allEntities[entity.Name] = entity
		templates, err := templateFS.ReadDir("tmpl")
		die(err)

		for _, f := range templates {
			if !strings.HasSuffix(f.Name(), ".gotmpl") || !f.Type().IsRegular() {
				continue
			}

			tmpl := f.Name()
			tag, _ := strings.CutSuffix(tmpl, ".gotmpl")
			tag, ok := strings.CutSuffix(tag, "_test")
			if ok {
				tag = "_" + tag + "_gen_test.go"
			} else {
				tag = "_" + tag + "_gen.go"
			}

			targetFile := filepath.Join(*flagLogTargetDir, entity.Name+tag)
			slog.InfoContext(ctx, "generating", slog.String("name", entity.Name), slog.String("template", tmpl))
			filename := strings.Builder{}

			filenameTmpl, err := template.New("name").Funcs(funcsMap).Parse(targetFile)
			die(err)

			err = filenameTmpl.Execute(&filename, entity)
			die(err)

			targetDir := filepath.Dir(filename.String())
			if !directoryExists(targetDir) {
				err = os.MkdirAll(targetDir, 0o700)
				die(err)
			}

			buf := bytes.Buffer{}

			_, err = buf.WriteString(generatedByPreamble)
			die(err)

			err = t.ExecuteTemplate(&buf, tmpl, entity)
			die(err)

			formattedSource, err := format.Source(buf.Bytes())
			if err != nil {
				formattedSource = buf.Bytes()
				slog.ErrorContext(ctx, "failed to format source", slog.Any("err", err), slog.String("target_filename", filename.String()))
			}

			err = os.WriteFile(filename.String(), formattedSource, 0o600)
			die(err)
		}
	}
}

// die is a convenience function to end the processing with a panic in the case of an error.
func die(err error) {
	if err != nil {
		slog.ErrorContext(context.Background(), "generate-event failed", slog.Any("err", err))
		panic("die")
	}
}

// directoryExists returns true, if the given path does exist and is of type
// directory. Symlinks are resolved, sucht that the effective target is checked.
// Otherwise false is returned.
func directoryExists(name string) bool {
	info, err := os.Stat(name)
	if err != nil && errors.Is(err, fs.ErrNotExist) {
		return false
	}

	return info.IsDir()
}
