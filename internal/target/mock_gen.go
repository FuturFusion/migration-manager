// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package target

import (
	"context"
	"crypto/x509"
	"encoding/json"
	"sync"

	"github.com/FuturFusion/migration-manager/internal/migration"
	"github.com/FuturFusion/migration-manager/shared/api"
	incus "github.com/lxc/incus/v6/client"
	incusAPI "github.com/lxc/incus/v6/shared/api"
)

// Ensure, that TargetMock does implement Target.
// If this is not the case, regenerate this file with moq.
var _ Target = &TargetMock{}

// TargetMock is a mock implementation of Target.
//
//	func TestSomethingThatUsesTarget(t *testing.T) {
//
//		// make and configure a mocked Target
//		mockedTarget := &TargetMock{
//			CheckIncusAgentFunc: func(ctx context.Context, instanceName string) error {
//				panic("mock out the CheckIncusAgent method")
//			},
//			CleanupVMFunc: func(ctx context.Context, name string, requireWorkerVolume bool) error {
//				panic("mock out the CleanupVM method")
//			},
//			ConnectFunc: func(ctx context.Context) error {
//				panic("mock out the Connect method")
//			},
//			CreateNewVMFunc: func(ctx context.Context, instDef migration.Instance, apiDef incusAPI.InstancesPost, placement api.Placement, bootISOImage string) (func(), error) {
//				panic("mock out the CreateNewVM method")
//			},
//			CreateStoragePoolVolumeFromBackupFunc: func(poolName string, backupFilePath string, architecture string, volumeName string) ([]incus.Operation, func(), error) {
//				panic("mock out the CreateStoragePoolVolumeFromBackup method")
//			},
//			CreateStoragePoolVolumeFromISOFunc: func(pool string, isoFilePath string) ([]incus.Operation, error) {
//				panic("mock out the CreateStoragePoolVolumeFromISO method")
//			},
//			CreateVMDefinitionFunc: func(instanceDef migration.Instance, usedNetworks migration.Networks, q migration.QueueEntry, fingerprint string, endpoint string) (incusAPI.InstancesPost, error) {
//				panic("mock out the CreateVMDefinition method")
//			},
//			DeleteVMFunc: func(ctx context.Context, name string) error {
//				panic("mock out the DeleteVM method")
//			},
//			DisconnectFunc: func(ctx context.Context) error {
//				panic("mock out the Disconnect method")
//			},
//			DoBasicConnectivityCheckFunc: func() (api.ExternalConnectivityStatus, *x509.Certificate) {
//				panic("mock out the DoBasicConnectivityCheck method")
//			},
//			ExecFunc: func(ctx context.Context, instanceName string, cmd []string) error {
//				panic("mock out the Exec method")
//			},
//			GetDetailsFunc: func(ctx context.Context) (*IncusDetails, error) {
//				panic("mock out the GetDetails method")
//			},
//			GetInstanceFunc: func(name string) (*incusAPI.Instance, string, error) {
//				panic("mock out the GetInstance method")
//			},
//			GetInstanceNamesFunc: func() ([]string, error) {
//				panic("mock out the GetInstanceNames method")
//			},
//			GetNameFunc: func() string {
//				panic("mock out the GetName method")
//			},
//			GetPropertiesFunc: func() json.RawMessage {
//				panic("mock out the GetProperties method")
//			},
//			GetStoragePoolVolumeNamesFunc: func(pool string) ([]string, error) {
//				panic("mock out the GetStoragePoolVolumeNames method")
//			},
//			IsConnectedFunc: func() bool {
//				panic("mock out the IsConnected method")
//			},
//			IsWaitingForOIDCTokensFunc: func() bool {
//				panic("mock out the IsWaitingForOIDCTokens method")
//			},
//			PushFileFunc: func(instanceName string, file string, destDir string) error {
//				panic("mock out the PushFile method")
//			},
//			SetClientTLSCredentialsFunc: func(key string, cert string) error {
//				panic("mock out the SetClientTLSCredentials method")
//			},
//			SetPostMigrationVMConfigFunc: func(ctx context.Context, i migration.Instance, q migration.QueueEntry) error {
//				panic("mock out the SetPostMigrationVMConfig method")
//			},
//			SetProjectFunc: func(project string) error {
//				panic("mock out the SetProject method")
//			},
//			StartVMFunc: func(ctx context.Context, name string) error {
//				panic("mock out the StartVM method")
//			},
//			StopVMFunc: func(ctx context.Context, name string, force bool) error {
//				panic("mock out the StopVM method")
//			},
//			UpdateInstanceFunc: func(name string, instanceDef incusAPI.InstancePut, ETag string) (incus.Operation, error) {
//				panic("mock out the UpdateInstance method")
//			},
//			WithAdditionalRootCertificateFunc: func(rootCert *x509.Certificate)  {
//				panic("mock out the WithAdditionalRootCertificate method")
//			},
//		}
//
//		// use mockedTarget in code that requires Target
//		// and then make assertions.
//
//	}
type TargetMock struct {
	// CheckIncusAgentFunc mocks the CheckIncusAgent method.
	CheckIncusAgentFunc func(ctx context.Context, instanceName string) error

	// CleanupVMFunc mocks the CleanupVM method.
	CleanupVMFunc func(ctx context.Context, name string, requireWorkerVolume bool) error

	// ConnectFunc mocks the Connect method.
	ConnectFunc func(ctx context.Context) error

	// CreateNewVMFunc mocks the CreateNewVM method.
	CreateNewVMFunc func(ctx context.Context, instDef migration.Instance, apiDef incusAPI.InstancesPost, placement api.Placement, bootISOImage string) (func(), error)

	// CreateStoragePoolVolumeFromBackupFunc mocks the CreateStoragePoolVolumeFromBackup method.
	CreateStoragePoolVolumeFromBackupFunc func(poolName string, backupFilePath string, architecture string, volumeName string) ([]incus.Operation, func(), error)

	// CreateStoragePoolVolumeFromISOFunc mocks the CreateStoragePoolVolumeFromISO method.
	CreateStoragePoolVolumeFromISOFunc func(pool string, isoFilePath string) ([]incus.Operation, error)

	// CreateVMDefinitionFunc mocks the CreateVMDefinition method.
	CreateVMDefinitionFunc func(instanceDef migration.Instance, usedNetworks migration.Networks, q migration.QueueEntry, fingerprint string, endpoint string) (incusAPI.InstancesPost, error)

	// DeleteVMFunc mocks the DeleteVM method.
	DeleteVMFunc func(ctx context.Context, name string) error

	// DisconnectFunc mocks the Disconnect method.
	DisconnectFunc func(ctx context.Context) error

	// DoBasicConnectivityCheckFunc mocks the DoBasicConnectivityCheck method.
	DoBasicConnectivityCheckFunc func() (api.ExternalConnectivityStatus, *x509.Certificate)

	// ExecFunc mocks the Exec method.
	ExecFunc func(ctx context.Context, instanceName string, cmd []string) error

	// GetDetailsFunc mocks the GetDetails method.
	GetDetailsFunc func(ctx context.Context) (*IncusDetails, error)

	// GetInstanceFunc mocks the GetInstance method.
	GetInstanceFunc func(name string) (*incusAPI.Instance, string, error)

	// GetInstanceNamesFunc mocks the GetInstanceNames method.
	GetInstanceNamesFunc func() ([]string, error)

	// GetNameFunc mocks the GetName method.
	GetNameFunc func() string

	// GetPropertiesFunc mocks the GetProperties method.
	GetPropertiesFunc func() json.RawMessage

	// GetStoragePoolVolumeNamesFunc mocks the GetStoragePoolVolumeNames method.
	GetStoragePoolVolumeNamesFunc func(pool string) ([]string, error)

	// IsConnectedFunc mocks the IsConnected method.
	IsConnectedFunc func() bool

	// IsWaitingForOIDCTokensFunc mocks the IsWaitingForOIDCTokens method.
	IsWaitingForOIDCTokensFunc func() bool

	// PushFileFunc mocks the PushFile method.
	PushFileFunc func(instanceName string, file string, destDir string) error

	// SetClientTLSCredentialsFunc mocks the SetClientTLSCredentials method.
	SetClientTLSCredentialsFunc func(key string, cert string) error

	// SetPostMigrationVMConfigFunc mocks the SetPostMigrationVMConfig method.
	SetPostMigrationVMConfigFunc func(ctx context.Context, i migration.Instance, q migration.QueueEntry) error

	// SetProjectFunc mocks the SetProject method.
	SetProjectFunc func(project string) error

	// StartVMFunc mocks the StartVM method.
	StartVMFunc func(ctx context.Context, name string) error

	// StopVMFunc mocks the StopVM method.
	StopVMFunc func(ctx context.Context, name string, force bool) error

	// UpdateInstanceFunc mocks the UpdateInstance method.
	UpdateInstanceFunc func(name string, instanceDef incusAPI.InstancePut, ETag string) (incus.Operation, error)

	// WithAdditionalRootCertificateFunc mocks the WithAdditionalRootCertificate method.
	WithAdditionalRootCertificateFunc func(rootCert *x509.Certificate)

	// calls tracks calls to the methods.
	calls struct {
		// CheckIncusAgent holds details about calls to the CheckIncusAgent method.
		CheckIncusAgent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceName is the instanceName argument value.
			InstanceName string
		}
		// CleanupVM holds details about calls to the CleanupVM method.
		CleanupVM []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// RequireWorkerVolume is the requireWorkerVolume argument value.
			RequireWorkerVolume bool
		}
		// Connect holds details about calls to the Connect method.
		Connect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CreateNewVM holds details about calls to the CreateNewVM method.
		CreateNewVM []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstDef is the instDef argument value.
			InstDef migration.Instance
			// ApiDef is the apiDef argument value.
			ApiDef incusAPI.InstancesPost
			// Placement is the placement argument value.
			Placement api.Placement
			// BootISOImage is the bootISOImage argument value.
			BootISOImage string
		}
		// CreateStoragePoolVolumeFromBackup holds details about calls to the CreateStoragePoolVolumeFromBackup method.
		CreateStoragePoolVolumeFromBackup []struct {
			// PoolName is the poolName argument value.
			PoolName string
			// BackupFilePath is the backupFilePath argument value.
			BackupFilePath string
			// Architecture is the architecture argument value.
			Architecture string
			// VolumeName is the volumeName argument value.
			VolumeName string
		}
		// CreateStoragePoolVolumeFromISO holds details about calls to the CreateStoragePoolVolumeFromISO method.
		CreateStoragePoolVolumeFromISO []struct {
			// Pool is the pool argument value.
			Pool string
			// IsoFilePath is the isoFilePath argument value.
			IsoFilePath string
		}
		// CreateVMDefinition holds details about calls to the CreateVMDefinition method.
		CreateVMDefinition []struct {
			// InstanceDef is the instanceDef argument value.
			InstanceDef migration.Instance
			// UsedNetworks is the usedNetworks argument value.
			UsedNetworks migration.Networks
			// Q is the q argument value.
			Q migration.QueueEntry
			// Fingerprint is the fingerprint argument value.
			Fingerprint string
			// Endpoint is the endpoint argument value.
			Endpoint string
		}
		// DeleteVM holds details about calls to the DeleteVM method.
		DeleteVM []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// Disconnect holds details about calls to the Disconnect method.
		Disconnect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// DoBasicConnectivityCheck holds details about calls to the DoBasicConnectivityCheck method.
		DoBasicConnectivityCheck []struct {
		}
		// Exec holds details about calls to the Exec method.
		Exec []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InstanceName is the instanceName argument value.
			InstanceName string
			// Cmd is the cmd argument value.
			Cmd []string
		}
		// GetDetails holds details about calls to the GetDetails method.
		GetDetails []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetInstance holds details about calls to the GetInstance method.
		GetInstance []struct {
			// Name is the name argument value.
			Name string
		}
		// GetInstanceNames holds details about calls to the GetInstanceNames method.
		GetInstanceNames []struct {
		}
		// GetName holds details about calls to the GetName method.
		GetName []struct {
		}
		// GetProperties holds details about calls to the GetProperties method.
		GetProperties []struct {
		}
		// GetStoragePoolVolumeNames holds details about calls to the GetStoragePoolVolumeNames method.
		GetStoragePoolVolumeNames []struct {
			// Pool is the pool argument value.
			Pool string
		}
		// IsConnected holds details about calls to the IsConnected method.
		IsConnected []struct {
		}
		// IsWaitingForOIDCTokens holds details about calls to the IsWaitingForOIDCTokens method.
		IsWaitingForOIDCTokens []struct {
		}
		// PushFile holds details about calls to the PushFile method.
		PushFile []struct {
			// InstanceName is the instanceName argument value.
			InstanceName string
			// File is the file argument value.
			File string
			// DestDir is the destDir argument value.
			DestDir string
		}
		// SetClientTLSCredentials holds details about calls to the SetClientTLSCredentials method.
		SetClientTLSCredentials []struct {
			// Key is the key argument value.
			Key string
			// Cert is the cert argument value.
			Cert string
		}
		// SetPostMigrationVMConfig holds details about calls to the SetPostMigrationVMConfig method.
		SetPostMigrationVMConfig []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// I is the i argument value.
			I migration.Instance
			// Q is the q argument value.
			Q migration.QueueEntry
		}
		// SetProject holds details about calls to the SetProject method.
		SetProject []struct {
			// Project is the project argument value.
			Project string
		}
		// StartVM holds details about calls to the StartVM method.
		StartVM []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// StopVM holds details about calls to the StopVM method.
		StopVM []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Force is the force argument value.
			Force bool
		}
		// UpdateInstance holds details about calls to the UpdateInstance method.
		UpdateInstance []struct {
			// Name is the name argument value.
			Name string
			// InstanceDef is the instanceDef argument value.
			InstanceDef incusAPI.InstancePut
			// ETag is the ETag argument value.
			ETag string
		}
		// WithAdditionalRootCertificate holds details about calls to the WithAdditionalRootCertificate method.
		WithAdditionalRootCertificate []struct {
			// RootCert is the rootCert argument value.
			RootCert *x509.Certificate
		}
	}
	lockCheckIncusAgent                   sync.RWMutex
	lockCleanupVM                         sync.RWMutex
	lockConnect                           sync.RWMutex
	lockCreateNewVM                       sync.RWMutex
	lockCreateStoragePoolVolumeFromBackup sync.RWMutex
	lockCreateStoragePoolVolumeFromISO    sync.RWMutex
	lockCreateVMDefinition                sync.RWMutex
	lockDeleteVM                          sync.RWMutex
	lockDisconnect                        sync.RWMutex
	lockDoBasicConnectivityCheck          sync.RWMutex
	lockExec                              sync.RWMutex
	lockGetDetails                        sync.RWMutex
	lockGetInstance                       sync.RWMutex
	lockGetInstanceNames                  sync.RWMutex
	lockGetName                           sync.RWMutex
	lockGetProperties                     sync.RWMutex
	lockGetStoragePoolVolumeNames         sync.RWMutex
	lockIsConnected                       sync.RWMutex
	lockIsWaitingForOIDCTokens            sync.RWMutex
	lockPushFile                          sync.RWMutex
	lockSetClientTLSCredentials           sync.RWMutex
	lockSetPostMigrationVMConfig          sync.RWMutex
	lockSetProject                        sync.RWMutex
	lockStartVM                           sync.RWMutex
	lockStopVM                            sync.RWMutex
	lockUpdateInstance                    sync.RWMutex
	lockWithAdditionalRootCertificate     sync.RWMutex
}

// CheckIncusAgent calls CheckIncusAgentFunc.
func (mock *TargetMock) CheckIncusAgent(ctx context.Context, instanceName string) error {
	if mock.CheckIncusAgentFunc == nil {
		panic("TargetMock.CheckIncusAgentFunc: method is nil but Target.CheckIncusAgent was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		InstanceName string
	}{
		Ctx:          ctx,
		InstanceName: instanceName,
	}
	mock.lockCheckIncusAgent.Lock()
	mock.calls.CheckIncusAgent = append(mock.calls.CheckIncusAgent, callInfo)
	mock.lockCheckIncusAgent.Unlock()
	return mock.CheckIncusAgentFunc(ctx, instanceName)
}

// CheckIncusAgentCalls gets all the calls that were made to CheckIncusAgent.
// Check the length with:
//
//	len(mockedTarget.CheckIncusAgentCalls())
func (mock *TargetMock) CheckIncusAgentCalls() []struct {
	Ctx          context.Context
	InstanceName string
} {
	var calls []struct {
		Ctx          context.Context
		InstanceName string
	}
	mock.lockCheckIncusAgent.RLock()
	calls = mock.calls.CheckIncusAgent
	mock.lockCheckIncusAgent.RUnlock()
	return calls
}

// CleanupVM calls CleanupVMFunc.
func (mock *TargetMock) CleanupVM(ctx context.Context, name string, requireWorkerVolume bool) error {
	if mock.CleanupVMFunc == nil {
		panic("TargetMock.CleanupVMFunc: method is nil but Target.CleanupVM was just called")
	}
	callInfo := struct {
		Ctx                 context.Context
		Name                string
		RequireWorkerVolume bool
	}{
		Ctx:                 ctx,
		Name:                name,
		RequireWorkerVolume: requireWorkerVolume,
	}
	mock.lockCleanupVM.Lock()
	mock.calls.CleanupVM = append(mock.calls.CleanupVM, callInfo)
	mock.lockCleanupVM.Unlock()
	return mock.CleanupVMFunc(ctx, name, requireWorkerVolume)
}

// CleanupVMCalls gets all the calls that were made to CleanupVM.
// Check the length with:
//
//	len(mockedTarget.CleanupVMCalls())
func (mock *TargetMock) CleanupVMCalls() []struct {
	Ctx                 context.Context
	Name                string
	RequireWorkerVolume bool
} {
	var calls []struct {
		Ctx                 context.Context
		Name                string
		RequireWorkerVolume bool
	}
	mock.lockCleanupVM.RLock()
	calls = mock.calls.CleanupVM
	mock.lockCleanupVM.RUnlock()
	return calls
}

// Connect calls ConnectFunc.
func (mock *TargetMock) Connect(ctx context.Context) error {
	if mock.ConnectFunc == nil {
		panic("TargetMock.ConnectFunc: method is nil but Target.Connect was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockConnect.Lock()
	mock.calls.Connect = append(mock.calls.Connect, callInfo)
	mock.lockConnect.Unlock()
	return mock.ConnectFunc(ctx)
}

// ConnectCalls gets all the calls that were made to Connect.
// Check the length with:
//
//	len(mockedTarget.ConnectCalls())
func (mock *TargetMock) ConnectCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockConnect.RLock()
	calls = mock.calls.Connect
	mock.lockConnect.RUnlock()
	return calls
}

// CreateNewVM calls CreateNewVMFunc.
func (mock *TargetMock) CreateNewVM(ctx context.Context, instDef migration.Instance, apiDef incusAPI.InstancesPost, placement api.Placement, bootISOImage string) (func(), error) {
	if mock.CreateNewVMFunc == nil {
		panic("TargetMock.CreateNewVMFunc: method is nil but Target.CreateNewVM was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		InstDef      migration.Instance
		ApiDef       incusAPI.InstancesPost
		Placement    api.Placement
		BootISOImage string
	}{
		Ctx:          ctx,
		InstDef:      instDef,
		ApiDef:       apiDef,
		Placement:    placement,
		BootISOImage: bootISOImage,
	}
	mock.lockCreateNewVM.Lock()
	mock.calls.CreateNewVM = append(mock.calls.CreateNewVM, callInfo)
	mock.lockCreateNewVM.Unlock()
	return mock.CreateNewVMFunc(ctx, instDef, apiDef, placement, bootISOImage)
}

// CreateNewVMCalls gets all the calls that were made to CreateNewVM.
// Check the length with:
//
//	len(mockedTarget.CreateNewVMCalls())
func (mock *TargetMock) CreateNewVMCalls() []struct {
	Ctx          context.Context
	InstDef      migration.Instance
	ApiDef       incusAPI.InstancesPost
	Placement    api.Placement
	BootISOImage string
} {
	var calls []struct {
		Ctx          context.Context
		InstDef      migration.Instance
		ApiDef       incusAPI.InstancesPost
		Placement    api.Placement
		BootISOImage string
	}
	mock.lockCreateNewVM.RLock()
	calls = mock.calls.CreateNewVM
	mock.lockCreateNewVM.RUnlock()
	return calls
}

// CreateStoragePoolVolumeFromBackup calls CreateStoragePoolVolumeFromBackupFunc.
func (mock *TargetMock) CreateStoragePoolVolumeFromBackup(poolName string, backupFilePath string, architecture string, volumeName string) ([]incus.Operation, func(), error) {
	if mock.CreateStoragePoolVolumeFromBackupFunc == nil {
		panic("TargetMock.CreateStoragePoolVolumeFromBackupFunc: method is nil but Target.CreateStoragePoolVolumeFromBackup was just called")
	}
	callInfo := struct {
		PoolName       string
		BackupFilePath string
		Architecture   string
		VolumeName     string
	}{
		PoolName:       poolName,
		BackupFilePath: backupFilePath,
		Architecture:   architecture,
		VolumeName:     volumeName,
	}
	mock.lockCreateStoragePoolVolumeFromBackup.Lock()
	mock.calls.CreateStoragePoolVolumeFromBackup = append(mock.calls.CreateStoragePoolVolumeFromBackup, callInfo)
	mock.lockCreateStoragePoolVolumeFromBackup.Unlock()
	return mock.CreateStoragePoolVolumeFromBackupFunc(poolName, backupFilePath, architecture, volumeName)
}

// CreateStoragePoolVolumeFromBackupCalls gets all the calls that were made to CreateStoragePoolVolumeFromBackup.
// Check the length with:
//
//	len(mockedTarget.CreateStoragePoolVolumeFromBackupCalls())
func (mock *TargetMock) CreateStoragePoolVolumeFromBackupCalls() []struct {
	PoolName       string
	BackupFilePath string
	Architecture   string
	VolumeName     string
} {
	var calls []struct {
		PoolName       string
		BackupFilePath string
		Architecture   string
		VolumeName     string
	}
	mock.lockCreateStoragePoolVolumeFromBackup.RLock()
	calls = mock.calls.CreateStoragePoolVolumeFromBackup
	mock.lockCreateStoragePoolVolumeFromBackup.RUnlock()
	return calls
}

// CreateStoragePoolVolumeFromISO calls CreateStoragePoolVolumeFromISOFunc.
func (mock *TargetMock) CreateStoragePoolVolumeFromISO(pool string, isoFilePath string) ([]incus.Operation, error) {
	if mock.CreateStoragePoolVolumeFromISOFunc == nil {
		panic("TargetMock.CreateStoragePoolVolumeFromISOFunc: method is nil but Target.CreateStoragePoolVolumeFromISO was just called")
	}
	callInfo := struct {
		Pool        string
		IsoFilePath string
	}{
		Pool:        pool,
		IsoFilePath: isoFilePath,
	}
	mock.lockCreateStoragePoolVolumeFromISO.Lock()
	mock.calls.CreateStoragePoolVolumeFromISO = append(mock.calls.CreateStoragePoolVolumeFromISO, callInfo)
	mock.lockCreateStoragePoolVolumeFromISO.Unlock()
	return mock.CreateStoragePoolVolumeFromISOFunc(pool, isoFilePath)
}

// CreateStoragePoolVolumeFromISOCalls gets all the calls that were made to CreateStoragePoolVolumeFromISO.
// Check the length with:
//
//	len(mockedTarget.CreateStoragePoolVolumeFromISOCalls())
func (mock *TargetMock) CreateStoragePoolVolumeFromISOCalls() []struct {
	Pool        string
	IsoFilePath string
} {
	var calls []struct {
		Pool        string
		IsoFilePath string
	}
	mock.lockCreateStoragePoolVolumeFromISO.RLock()
	calls = mock.calls.CreateStoragePoolVolumeFromISO
	mock.lockCreateStoragePoolVolumeFromISO.RUnlock()
	return calls
}

// CreateVMDefinition calls CreateVMDefinitionFunc.
func (mock *TargetMock) CreateVMDefinition(instanceDef migration.Instance, usedNetworks migration.Networks, q migration.QueueEntry, fingerprint string, endpoint string) (incusAPI.InstancesPost, error) {
	if mock.CreateVMDefinitionFunc == nil {
		panic("TargetMock.CreateVMDefinitionFunc: method is nil but Target.CreateVMDefinition was just called")
	}
	callInfo := struct {
		InstanceDef  migration.Instance
		UsedNetworks migration.Networks
		Q            migration.QueueEntry
		Fingerprint  string
		Endpoint     string
	}{
		InstanceDef:  instanceDef,
		UsedNetworks: usedNetworks,
		Q:            q,
		Fingerprint:  fingerprint,
		Endpoint:     endpoint,
	}
	mock.lockCreateVMDefinition.Lock()
	mock.calls.CreateVMDefinition = append(mock.calls.CreateVMDefinition, callInfo)
	mock.lockCreateVMDefinition.Unlock()
	return mock.CreateVMDefinitionFunc(instanceDef, usedNetworks, q, fingerprint, endpoint)
}

// CreateVMDefinitionCalls gets all the calls that were made to CreateVMDefinition.
// Check the length with:
//
//	len(mockedTarget.CreateVMDefinitionCalls())
func (mock *TargetMock) CreateVMDefinitionCalls() []struct {
	InstanceDef  migration.Instance
	UsedNetworks migration.Networks
	Q            migration.QueueEntry
	Fingerprint  string
	Endpoint     string
} {
	var calls []struct {
		InstanceDef  migration.Instance
		UsedNetworks migration.Networks
		Q            migration.QueueEntry
		Fingerprint  string
		Endpoint     string
	}
	mock.lockCreateVMDefinition.RLock()
	calls = mock.calls.CreateVMDefinition
	mock.lockCreateVMDefinition.RUnlock()
	return calls
}

// DeleteVM calls DeleteVMFunc.
func (mock *TargetMock) DeleteVM(ctx context.Context, name string) error {
	if mock.DeleteVMFunc == nil {
		panic("TargetMock.DeleteVMFunc: method is nil but Target.DeleteVM was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockDeleteVM.Lock()
	mock.calls.DeleteVM = append(mock.calls.DeleteVM, callInfo)
	mock.lockDeleteVM.Unlock()
	return mock.DeleteVMFunc(ctx, name)
}

// DeleteVMCalls gets all the calls that were made to DeleteVM.
// Check the length with:
//
//	len(mockedTarget.DeleteVMCalls())
func (mock *TargetMock) DeleteVMCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockDeleteVM.RLock()
	calls = mock.calls.DeleteVM
	mock.lockDeleteVM.RUnlock()
	return calls
}

// Disconnect calls DisconnectFunc.
func (mock *TargetMock) Disconnect(ctx context.Context) error {
	if mock.DisconnectFunc == nil {
		panic("TargetMock.DisconnectFunc: method is nil but Target.Disconnect was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockDisconnect.Lock()
	mock.calls.Disconnect = append(mock.calls.Disconnect, callInfo)
	mock.lockDisconnect.Unlock()
	return mock.DisconnectFunc(ctx)
}

// DisconnectCalls gets all the calls that were made to Disconnect.
// Check the length with:
//
//	len(mockedTarget.DisconnectCalls())
func (mock *TargetMock) DisconnectCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockDisconnect.RLock()
	calls = mock.calls.Disconnect
	mock.lockDisconnect.RUnlock()
	return calls
}

// DoBasicConnectivityCheck calls DoBasicConnectivityCheckFunc.
func (mock *TargetMock) DoBasicConnectivityCheck() (api.ExternalConnectivityStatus, *x509.Certificate) {
	if mock.DoBasicConnectivityCheckFunc == nil {
		panic("TargetMock.DoBasicConnectivityCheckFunc: method is nil but Target.DoBasicConnectivityCheck was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDoBasicConnectivityCheck.Lock()
	mock.calls.DoBasicConnectivityCheck = append(mock.calls.DoBasicConnectivityCheck, callInfo)
	mock.lockDoBasicConnectivityCheck.Unlock()
	return mock.DoBasicConnectivityCheckFunc()
}

// DoBasicConnectivityCheckCalls gets all the calls that were made to DoBasicConnectivityCheck.
// Check the length with:
//
//	len(mockedTarget.DoBasicConnectivityCheckCalls())
func (mock *TargetMock) DoBasicConnectivityCheckCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDoBasicConnectivityCheck.RLock()
	calls = mock.calls.DoBasicConnectivityCheck
	mock.lockDoBasicConnectivityCheck.RUnlock()
	return calls
}

// Exec calls ExecFunc.
func (mock *TargetMock) Exec(ctx context.Context, instanceName string, cmd []string) error {
	if mock.ExecFunc == nil {
		panic("TargetMock.ExecFunc: method is nil but Target.Exec was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		InstanceName string
		Cmd          []string
	}{
		Ctx:          ctx,
		InstanceName: instanceName,
		Cmd:          cmd,
	}
	mock.lockExec.Lock()
	mock.calls.Exec = append(mock.calls.Exec, callInfo)
	mock.lockExec.Unlock()
	return mock.ExecFunc(ctx, instanceName, cmd)
}

// ExecCalls gets all the calls that were made to Exec.
// Check the length with:
//
//	len(mockedTarget.ExecCalls())
func (mock *TargetMock) ExecCalls() []struct {
	Ctx          context.Context
	InstanceName string
	Cmd          []string
} {
	var calls []struct {
		Ctx          context.Context
		InstanceName string
		Cmd          []string
	}
	mock.lockExec.RLock()
	calls = mock.calls.Exec
	mock.lockExec.RUnlock()
	return calls
}

// GetDetails calls GetDetailsFunc.
func (mock *TargetMock) GetDetails(ctx context.Context) (*IncusDetails, error) {
	if mock.GetDetailsFunc == nil {
		panic("TargetMock.GetDetailsFunc: method is nil but Target.GetDetails was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetDetails.Lock()
	mock.calls.GetDetails = append(mock.calls.GetDetails, callInfo)
	mock.lockGetDetails.Unlock()
	return mock.GetDetailsFunc(ctx)
}

// GetDetailsCalls gets all the calls that were made to GetDetails.
// Check the length with:
//
//	len(mockedTarget.GetDetailsCalls())
func (mock *TargetMock) GetDetailsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetDetails.RLock()
	calls = mock.calls.GetDetails
	mock.lockGetDetails.RUnlock()
	return calls
}

// GetInstance calls GetInstanceFunc.
func (mock *TargetMock) GetInstance(name string) (*incusAPI.Instance, string, error) {
	if mock.GetInstanceFunc == nil {
		panic("TargetMock.GetInstanceFunc: method is nil but Target.GetInstance was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockGetInstance.Lock()
	mock.calls.GetInstance = append(mock.calls.GetInstance, callInfo)
	mock.lockGetInstance.Unlock()
	return mock.GetInstanceFunc(name)
}

// GetInstanceCalls gets all the calls that were made to GetInstance.
// Check the length with:
//
//	len(mockedTarget.GetInstanceCalls())
func (mock *TargetMock) GetInstanceCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockGetInstance.RLock()
	calls = mock.calls.GetInstance
	mock.lockGetInstance.RUnlock()
	return calls
}

// GetInstanceNames calls GetInstanceNamesFunc.
func (mock *TargetMock) GetInstanceNames() ([]string, error) {
	if mock.GetInstanceNamesFunc == nil {
		panic("TargetMock.GetInstanceNamesFunc: method is nil but Target.GetInstanceNames was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetInstanceNames.Lock()
	mock.calls.GetInstanceNames = append(mock.calls.GetInstanceNames, callInfo)
	mock.lockGetInstanceNames.Unlock()
	return mock.GetInstanceNamesFunc()
}

// GetInstanceNamesCalls gets all the calls that were made to GetInstanceNames.
// Check the length with:
//
//	len(mockedTarget.GetInstanceNamesCalls())
func (mock *TargetMock) GetInstanceNamesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetInstanceNames.RLock()
	calls = mock.calls.GetInstanceNames
	mock.lockGetInstanceNames.RUnlock()
	return calls
}

// GetName calls GetNameFunc.
func (mock *TargetMock) GetName() string {
	if mock.GetNameFunc == nil {
		panic("TargetMock.GetNameFunc: method is nil but Target.GetName was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetName.Lock()
	mock.calls.GetName = append(mock.calls.GetName, callInfo)
	mock.lockGetName.Unlock()
	return mock.GetNameFunc()
}

// GetNameCalls gets all the calls that were made to GetName.
// Check the length with:
//
//	len(mockedTarget.GetNameCalls())
func (mock *TargetMock) GetNameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetName.RLock()
	calls = mock.calls.GetName
	mock.lockGetName.RUnlock()
	return calls
}

// GetProperties calls GetPropertiesFunc.
func (mock *TargetMock) GetProperties() json.RawMessage {
	if mock.GetPropertiesFunc == nil {
		panic("TargetMock.GetPropertiesFunc: method is nil but Target.GetProperties was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetProperties.Lock()
	mock.calls.GetProperties = append(mock.calls.GetProperties, callInfo)
	mock.lockGetProperties.Unlock()
	return mock.GetPropertiesFunc()
}

// GetPropertiesCalls gets all the calls that were made to GetProperties.
// Check the length with:
//
//	len(mockedTarget.GetPropertiesCalls())
func (mock *TargetMock) GetPropertiesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetProperties.RLock()
	calls = mock.calls.GetProperties
	mock.lockGetProperties.RUnlock()
	return calls
}

// GetStoragePoolVolumeNames calls GetStoragePoolVolumeNamesFunc.
func (mock *TargetMock) GetStoragePoolVolumeNames(pool string) ([]string, error) {
	if mock.GetStoragePoolVolumeNamesFunc == nil {
		panic("TargetMock.GetStoragePoolVolumeNamesFunc: method is nil but Target.GetStoragePoolVolumeNames was just called")
	}
	callInfo := struct {
		Pool string
	}{
		Pool: pool,
	}
	mock.lockGetStoragePoolVolumeNames.Lock()
	mock.calls.GetStoragePoolVolumeNames = append(mock.calls.GetStoragePoolVolumeNames, callInfo)
	mock.lockGetStoragePoolVolumeNames.Unlock()
	return mock.GetStoragePoolVolumeNamesFunc(pool)
}

// GetStoragePoolVolumeNamesCalls gets all the calls that were made to GetStoragePoolVolumeNames.
// Check the length with:
//
//	len(mockedTarget.GetStoragePoolVolumeNamesCalls())
func (mock *TargetMock) GetStoragePoolVolumeNamesCalls() []struct {
	Pool string
} {
	var calls []struct {
		Pool string
	}
	mock.lockGetStoragePoolVolumeNames.RLock()
	calls = mock.calls.GetStoragePoolVolumeNames
	mock.lockGetStoragePoolVolumeNames.RUnlock()
	return calls
}

// IsConnected calls IsConnectedFunc.
func (mock *TargetMock) IsConnected() bool {
	if mock.IsConnectedFunc == nil {
		panic("TargetMock.IsConnectedFunc: method is nil but Target.IsConnected was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsConnected.Lock()
	mock.calls.IsConnected = append(mock.calls.IsConnected, callInfo)
	mock.lockIsConnected.Unlock()
	return mock.IsConnectedFunc()
}

// IsConnectedCalls gets all the calls that were made to IsConnected.
// Check the length with:
//
//	len(mockedTarget.IsConnectedCalls())
func (mock *TargetMock) IsConnectedCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsConnected.RLock()
	calls = mock.calls.IsConnected
	mock.lockIsConnected.RUnlock()
	return calls
}

// IsWaitingForOIDCTokens calls IsWaitingForOIDCTokensFunc.
func (mock *TargetMock) IsWaitingForOIDCTokens() bool {
	if mock.IsWaitingForOIDCTokensFunc == nil {
		panic("TargetMock.IsWaitingForOIDCTokensFunc: method is nil but Target.IsWaitingForOIDCTokens was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsWaitingForOIDCTokens.Lock()
	mock.calls.IsWaitingForOIDCTokens = append(mock.calls.IsWaitingForOIDCTokens, callInfo)
	mock.lockIsWaitingForOIDCTokens.Unlock()
	return mock.IsWaitingForOIDCTokensFunc()
}

// IsWaitingForOIDCTokensCalls gets all the calls that were made to IsWaitingForOIDCTokens.
// Check the length with:
//
//	len(mockedTarget.IsWaitingForOIDCTokensCalls())
func (mock *TargetMock) IsWaitingForOIDCTokensCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsWaitingForOIDCTokens.RLock()
	calls = mock.calls.IsWaitingForOIDCTokens
	mock.lockIsWaitingForOIDCTokens.RUnlock()
	return calls
}

// PushFile calls PushFileFunc.
func (mock *TargetMock) PushFile(instanceName string, file string, destDir string) error {
	if mock.PushFileFunc == nil {
		panic("TargetMock.PushFileFunc: method is nil but Target.PushFile was just called")
	}
	callInfo := struct {
		InstanceName string
		File         string
		DestDir      string
	}{
		InstanceName: instanceName,
		File:         file,
		DestDir:      destDir,
	}
	mock.lockPushFile.Lock()
	mock.calls.PushFile = append(mock.calls.PushFile, callInfo)
	mock.lockPushFile.Unlock()
	return mock.PushFileFunc(instanceName, file, destDir)
}

// PushFileCalls gets all the calls that were made to PushFile.
// Check the length with:
//
//	len(mockedTarget.PushFileCalls())
func (mock *TargetMock) PushFileCalls() []struct {
	InstanceName string
	File         string
	DestDir      string
} {
	var calls []struct {
		InstanceName string
		File         string
		DestDir      string
	}
	mock.lockPushFile.RLock()
	calls = mock.calls.PushFile
	mock.lockPushFile.RUnlock()
	return calls
}

// SetClientTLSCredentials calls SetClientTLSCredentialsFunc.
func (mock *TargetMock) SetClientTLSCredentials(key string, cert string) error {
	if mock.SetClientTLSCredentialsFunc == nil {
		panic("TargetMock.SetClientTLSCredentialsFunc: method is nil but Target.SetClientTLSCredentials was just called")
	}
	callInfo := struct {
		Key  string
		Cert string
	}{
		Key:  key,
		Cert: cert,
	}
	mock.lockSetClientTLSCredentials.Lock()
	mock.calls.SetClientTLSCredentials = append(mock.calls.SetClientTLSCredentials, callInfo)
	mock.lockSetClientTLSCredentials.Unlock()
	return mock.SetClientTLSCredentialsFunc(key, cert)
}

// SetClientTLSCredentialsCalls gets all the calls that were made to SetClientTLSCredentials.
// Check the length with:
//
//	len(mockedTarget.SetClientTLSCredentialsCalls())
func (mock *TargetMock) SetClientTLSCredentialsCalls() []struct {
	Key  string
	Cert string
} {
	var calls []struct {
		Key  string
		Cert string
	}
	mock.lockSetClientTLSCredentials.RLock()
	calls = mock.calls.SetClientTLSCredentials
	mock.lockSetClientTLSCredentials.RUnlock()
	return calls
}

// SetPostMigrationVMConfig calls SetPostMigrationVMConfigFunc.
func (mock *TargetMock) SetPostMigrationVMConfig(ctx context.Context, i migration.Instance, q migration.QueueEntry) error {
	if mock.SetPostMigrationVMConfigFunc == nil {
		panic("TargetMock.SetPostMigrationVMConfigFunc: method is nil but Target.SetPostMigrationVMConfig was just called")
	}
	callInfo := struct {
		Ctx context.Context
		I   migration.Instance
		Q   migration.QueueEntry
	}{
		Ctx: ctx,
		I:   i,
		Q:   q,
	}
	mock.lockSetPostMigrationVMConfig.Lock()
	mock.calls.SetPostMigrationVMConfig = append(mock.calls.SetPostMigrationVMConfig, callInfo)
	mock.lockSetPostMigrationVMConfig.Unlock()
	return mock.SetPostMigrationVMConfigFunc(ctx, i, q)
}

// SetPostMigrationVMConfigCalls gets all the calls that were made to SetPostMigrationVMConfig.
// Check the length with:
//
//	len(mockedTarget.SetPostMigrationVMConfigCalls())
func (mock *TargetMock) SetPostMigrationVMConfigCalls() []struct {
	Ctx context.Context
	I   migration.Instance
	Q   migration.QueueEntry
} {
	var calls []struct {
		Ctx context.Context
		I   migration.Instance
		Q   migration.QueueEntry
	}
	mock.lockSetPostMigrationVMConfig.RLock()
	calls = mock.calls.SetPostMigrationVMConfig
	mock.lockSetPostMigrationVMConfig.RUnlock()
	return calls
}

// SetProject calls SetProjectFunc.
func (mock *TargetMock) SetProject(project string) error {
	if mock.SetProjectFunc == nil {
		panic("TargetMock.SetProjectFunc: method is nil but Target.SetProject was just called")
	}
	callInfo := struct {
		Project string
	}{
		Project: project,
	}
	mock.lockSetProject.Lock()
	mock.calls.SetProject = append(mock.calls.SetProject, callInfo)
	mock.lockSetProject.Unlock()
	return mock.SetProjectFunc(project)
}

// SetProjectCalls gets all the calls that were made to SetProject.
// Check the length with:
//
//	len(mockedTarget.SetProjectCalls())
func (mock *TargetMock) SetProjectCalls() []struct {
	Project string
} {
	var calls []struct {
		Project string
	}
	mock.lockSetProject.RLock()
	calls = mock.calls.SetProject
	mock.lockSetProject.RUnlock()
	return calls
}

// StartVM calls StartVMFunc.
func (mock *TargetMock) StartVM(ctx context.Context, name string) error {
	if mock.StartVMFunc == nil {
		panic("TargetMock.StartVMFunc: method is nil but Target.StartVM was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockStartVM.Lock()
	mock.calls.StartVM = append(mock.calls.StartVM, callInfo)
	mock.lockStartVM.Unlock()
	return mock.StartVMFunc(ctx, name)
}

// StartVMCalls gets all the calls that were made to StartVM.
// Check the length with:
//
//	len(mockedTarget.StartVMCalls())
func (mock *TargetMock) StartVMCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockStartVM.RLock()
	calls = mock.calls.StartVM
	mock.lockStartVM.RUnlock()
	return calls
}

// StopVM calls StopVMFunc.
func (mock *TargetMock) StopVM(ctx context.Context, name string, force bool) error {
	if mock.StopVMFunc == nil {
		panic("TargetMock.StopVMFunc: method is nil but Target.StopVM was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Name  string
		Force bool
	}{
		Ctx:   ctx,
		Name:  name,
		Force: force,
	}
	mock.lockStopVM.Lock()
	mock.calls.StopVM = append(mock.calls.StopVM, callInfo)
	mock.lockStopVM.Unlock()
	return mock.StopVMFunc(ctx, name, force)
}

// StopVMCalls gets all the calls that were made to StopVM.
// Check the length with:
//
//	len(mockedTarget.StopVMCalls())
func (mock *TargetMock) StopVMCalls() []struct {
	Ctx   context.Context
	Name  string
	Force bool
} {
	var calls []struct {
		Ctx   context.Context
		Name  string
		Force bool
	}
	mock.lockStopVM.RLock()
	calls = mock.calls.StopVM
	mock.lockStopVM.RUnlock()
	return calls
}

// UpdateInstance calls UpdateInstanceFunc.
func (mock *TargetMock) UpdateInstance(name string, instanceDef incusAPI.InstancePut, ETag string) (incus.Operation, error) {
	if mock.UpdateInstanceFunc == nil {
		panic("TargetMock.UpdateInstanceFunc: method is nil but Target.UpdateInstance was just called")
	}
	callInfo := struct {
		Name        string
		InstanceDef incusAPI.InstancePut
		ETag        string
	}{
		Name:        name,
		InstanceDef: instanceDef,
		ETag:        ETag,
	}
	mock.lockUpdateInstance.Lock()
	mock.calls.UpdateInstance = append(mock.calls.UpdateInstance, callInfo)
	mock.lockUpdateInstance.Unlock()
	return mock.UpdateInstanceFunc(name, instanceDef, ETag)
}

// UpdateInstanceCalls gets all the calls that were made to UpdateInstance.
// Check the length with:
//
//	len(mockedTarget.UpdateInstanceCalls())
func (mock *TargetMock) UpdateInstanceCalls() []struct {
	Name        string
	InstanceDef incusAPI.InstancePut
	ETag        string
} {
	var calls []struct {
		Name        string
		InstanceDef incusAPI.InstancePut
		ETag        string
	}
	mock.lockUpdateInstance.RLock()
	calls = mock.calls.UpdateInstance
	mock.lockUpdateInstance.RUnlock()
	return calls
}

// WithAdditionalRootCertificate calls WithAdditionalRootCertificateFunc.
func (mock *TargetMock) WithAdditionalRootCertificate(rootCert *x509.Certificate) {
	if mock.WithAdditionalRootCertificateFunc == nil {
		panic("TargetMock.WithAdditionalRootCertificateFunc: method is nil but Target.WithAdditionalRootCertificate was just called")
	}
	callInfo := struct {
		RootCert *x509.Certificate
	}{
		RootCert: rootCert,
	}
	mock.lockWithAdditionalRootCertificate.Lock()
	mock.calls.WithAdditionalRootCertificate = append(mock.calls.WithAdditionalRootCertificate, callInfo)
	mock.lockWithAdditionalRootCertificate.Unlock()
	mock.WithAdditionalRootCertificateFunc(rootCert)
}

// WithAdditionalRootCertificateCalls gets all the calls that were made to WithAdditionalRootCertificate.
// Check the length with:
//
//	len(mockedTarget.WithAdditionalRootCertificateCalls())
func (mock *TargetMock) WithAdditionalRootCertificateCalls() []struct {
	RootCert *x509.Certificate
} {
	var calls []struct {
		RootCert *x509.Certificate
	}
	mock.lockWithAdditionalRootCertificate.RLock()
	calls = mock.calls.WithAdditionalRootCertificate
	mock.lockWithAdditionalRootCertificate.RUnlock()
	return calls
}
