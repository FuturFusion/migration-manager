// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package source

import (
	"context"
	"crypto/x509"
	"sync"

	"github.com/FuturFusion/migration-manager/internal/migration"
	"github.com/FuturFusion/migration-manager/shared/api"
)

// Ensure, that SourceMock does implement Source.
// If this is not the case, regenerate this file with moq.
var _ Source = &SourceMock{}

// SourceMock is a mock implementation of Source.
//
//	func TestSomethingThatUsesSource(t *testing.T) {
//
//		// make and configure a mocked Source
//		mockedSource := &SourceMock{
//			ConnectFunc: func(ctx context.Context) error {
//				panic("mock out the Connect method")
//			},
//			DeleteVMSnapshotFunc: func(ctx context.Context, vmName string, snapshotName string) error {
//				panic("mock out the DeleteVMSnapshot method")
//			},
//			DisconnectFunc: func(ctx context.Context) error {
//				panic("mock out the Disconnect method")
//			},
//			DoBasicConnectivityCheckFunc: func() (api.ExternalConnectivityStatus, *x509.Certificate) {
//				panic("mock out the DoBasicConnectivityCheck method")
//			},
//			GetAllNetworksFunc: func(ctx context.Context) ([]api.Network, error) {
//				panic("mock out the GetAllNetworks method")
//			},
//			GetAllVMsFunc: func(ctx context.Context) (migration.Instances, error) {
//				panic("mock out the GetAllVMs method")
//			},
//			GetNameFunc: func() string {
//				panic("mock out the GetName method")
//			},
//			ImportDisksFunc: func(ctx context.Context, vmName string, statusCallback func(string, bool)) error {
//				panic("mock out the ImportDisks method")
//			},
//			IsConnectedFunc: func() bool {
//				panic("mock out the IsConnected method")
//			},
//			PowerOffVMFunc: func(ctx context.Context, vmName string) error {
//				panic("mock out the PowerOffVM method")
//			},
//			WithAdditionalRootCertificateFunc: func(rootCert *x509.Certificate)  {
//				panic("mock out the WithAdditionalRootCertificate method")
//			},
//		}
//
//		// use mockedSource in code that requires Source
//		// and then make assertions.
//
//	}
type SourceMock struct {
	// ConnectFunc mocks the Connect method.
	ConnectFunc func(ctx context.Context) error

	// DeleteVMSnapshotFunc mocks the DeleteVMSnapshot method.
	DeleteVMSnapshotFunc func(ctx context.Context, vmName string, snapshotName string) error

	// DisconnectFunc mocks the Disconnect method.
	DisconnectFunc func(ctx context.Context) error

	// DoBasicConnectivityCheckFunc mocks the DoBasicConnectivityCheck method.
	DoBasicConnectivityCheckFunc func() (api.ExternalConnectivityStatus, *x509.Certificate)

	// GetAllNetworksFunc mocks the GetAllNetworks method.
	GetAllNetworksFunc func(ctx context.Context) ([]api.Network, error)

	// GetAllVMsFunc mocks the GetAllVMs method.
	GetAllVMsFunc func(ctx context.Context) (migration.Instances, error)

	// GetNameFunc mocks the GetName method.
	GetNameFunc func() string

	// ImportDisksFunc mocks the ImportDisks method.
	ImportDisksFunc func(ctx context.Context, vmName string, statusCallback func(string, bool)) error

	// IsConnectedFunc mocks the IsConnected method.
	IsConnectedFunc func() bool

	// PowerOffVMFunc mocks the PowerOffVM method.
	PowerOffVMFunc func(ctx context.Context, vmName string) error

	// WithAdditionalRootCertificateFunc mocks the WithAdditionalRootCertificate method.
	WithAdditionalRootCertificateFunc func(rootCert *x509.Certificate)

	// calls tracks calls to the methods.
	calls struct {
		// Connect holds details about calls to the Connect method.
		Connect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// DeleteVMSnapshot holds details about calls to the DeleteVMSnapshot method.
		DeleteVMSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// VmName is the vmName argument value.
			VmName string
			// SnapshotName is the snapshotName argument value.
			SnapshotName string
		}
		// Disconnect holds details about calls to the Disconnect method.
		Disconnect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// DoBasicConnectivityCheck holds details about calls to the DoBasicConnectivityCheck method.
		DoBasicConnectivityCheck []struct {
		}
		// GetAllNetworks holds details about calls to the GetAllNetworks method.
		GetAllNetworks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetAllVMs holds details about calls to the GetAllVMs method.
		GetAllVMs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetName holds details about calls to the GetName method.
		GetName []struct {
		}
		// ImportDisks holds details about calls to the ImportDisks method.
		ImportDisks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// VmName is the vmName argument value.
			VmName string
			// StatusCallback is the statusCallback argument value.
			StatusCallback func(string, bool)
		}
		// IsConnected holds details about calls to the IsConnected method.
		IsConnected []struct {
		}
		// PowerOffVM holds details about calls to the PowerOffVM method.
		PowerOffVM []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// VmName is the vmName argument value.
			VmName string
		}
		// WithAdditionalRootCertificate holds details about calls to the WithAdditionalRootCertificate method.
		WithAdditionalRootCertificate []struct {
			// RootCert is the rootCert argument value.
			RootCert *x509.Certificate
		}
	}
	lockConnect                       sync.RWMutex
	lockDeleteVMSnapshot              sync.RWMutex
	lockDisconnect                    sync.RWMutex
	lockDoBasicConnectivityCheck      sync.RWMutex
	lockGetAllNetworks                sync.RWMutex
	lockGetAllVMs                     sync.RWMutex
	lockGetName                       sync.RWMutex
	lockImportDisks                   sync.RWMutex
	lockIsConnected                   sync.RWMutex
	lockPowerOffVM                    sync.RWMutex
	lockWithAdditionalRootCertificate sync.RWMutex
}

// Connect calls ConnectFunc.
func (mock *SourceMock) Connect(ctx context.Context) error {
	if mock.ConnectFunc == nil {
		panic("SourceMock.ConnectFunc: method is nil but Source.Connect was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockConnect.Lock()
	mock.calls.Connect = append(mock.calls.Connect, callInfo)
	mock.lockConnect.Unlock()
	return mock.ConnectFunc(ctx)
}

// ConnectCalls gets all the calls that were made to Connect.
// Check the length with:
//
//	len(mockedSource.ConnectCalls())
func (mock *SourceMock) ConnectCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockConnect.RLock()
	calls = mock.calls.Connect
	mock.lockConnect.RUnlock()
	return calls
}

// DeleteVMSnapshot calls DeleteVMSnapshotFunc.
func (mock *SourceMock) DeleteVMSnapshot(ctx context.Context, vmName string, snapshotName string) error {
	if mock.DeleteVMSnapshotFunc == nil {
		panic("SourceMock.DeleteVMSnapshotFunc: method is nil but Source.DeleteVMSnapshot was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		VmName       string
		SnapshotName string
	}{
		Ctx:          ctx,
		VmName:       vmName,
		SnapshotName: snapshotName,
	}
	mock.lockDeleteVMSnapshot.Lock()
	mock.calls.DeleteVMSnapshot = append(mock.calls.DeleteVMSnapshot, callInfo)
	mock.lockDeleteVMSnapshot.Unlock()
	return mock.DeleteVMSnapshotFunc(ctx, vmName, snapshotName)
}

// DeleteVMSnapshotCalls gets all the calls that were made to DeleteVMSnapshot.
// Check the length with:
//
//	len(mockedSource.DeleteVMSnapshotCalls())
func (mock *SourceMock) DeleteVMSnapshotCalls() []struct {
	Ctx          context.Context
	VmName       string
	SnapshotName string
} {
	var calls []struct {
		Ctx          context.Context
		VmName       string
		SnapshotName string
	}
	mock.lockDeleteVMSnapshot.RLock()
	calls = mock.calls.DeleteVMSnapshot
	mock.lockDeleteVMSnapshot.RUnlock()
	return calls
}

// Disconnect calls DisconnectFunc.
func (mock *SourceMock) Disconnect(ctx context.Context) error {
	if mock.DisconnectFunc == nil {
		panic("SourceMock.DisconnectFunc: method is nil but Source.Disconnect was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockDisconnect.Lock()
	mock.calls.Disconnect = append(mock.calls.Disconnect, callInfo)
	mock.lockDisconnect.Unlock()
	return mock.DisconnectFunc(ctx)
}

// DisconnectCalls gets all the calls that were made to Disconnect.
// Check the length with:
//
//	len(mockedSource.DisconnectCalls())
func (mock *SourceMock) DisconnectCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockDisconnect.RLock()
	calls = mock.calls.Disconnect
	mock.lockDisconnect.RUnlock()
	return calls
}

// DoBasicConnectivityCheck calls DoBasicConnectivityCheckFunc.
func (mock *SourceMock) DoBasicConnectivityCheck() (api.ExternalConnectivityStatus, *x509.Certificate) {
	if mock.DoBasicConnectivityCheckFunc == nil {
		panic("SourceMock.DoBasicConnectivityCheckFunc: method is nil but Source.DoBasicConnectivityCheck was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDoBasicConnectivityCheck.Lock()
	mock.calls.DoBasicConnectivityCheck = append(mock.calls.DoBasicConnectivityCheck, callInfo)
	mock.lockDoBasicConnectivityCheck.Unlock()
	return mock.DoBasicConnectivityCheckFunc()
}

// DoBasicConnectivityCheckCalls gets all the calls that were made to DoBasicConnectivityCheck.
// Check the length with:
//
//	len(mockedSource.DoBasicConnectivityCheckCalls())
func (mock *SourceMock) DoBasicConnectivityCheckCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDoBasicConnectivityCheck.RLock()
	calls = mock.calls.DoBasicConnectivityCheck
	mock.lockDoBasicConnectivityCheck.RUnlock()
	return calls
}

// GetAllNetworks calls GetAllNetworksFunc.
func (mock *SourceMock) GetAllNetworks(ctx context.Context) ([]api.Network, error) {
	if mock.GetAllNetworksFunc == nil {
		panic("SourceMock.GetAllNetworksFunc: method is nil but Source.GetAllNetworks was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAllNetworks.Lock()
	mock.calls.GetAllNetworks = append(mock.calls.GetAllNetworks, callInfo)
	mock.lockGetAllNetworks.Unlock()
	return mock.GetAllNetworksFunc(ctx)
}

// GetAllNetworksCalls gets all the calls that were made to GetAllNetworks.
// Check the length with:
//
//	len(mockedSource.GetAllNetworksCalls())
func (mock *SourceMock) GetAllNetworksCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAllNetworks.RLock()
	calls = mock.calls.GetAllNetworks
	mock.lockGetAllNetworks.RUnlock()
	return calls
}

// GetAllVMs calls GetAllVMsFunc.
func (mock *SourceMock) GetAllVMs(ctx context.Context) (migration.Instances, error) {
	if mock.GetAllVMsFunc == nil {
		panic("SourceMock.GetAllVMsFunc: method is nil but Source.GetAllVMs was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAllVMs.Lock()
	mock.calls.GetAllVMs = append(mock.calls.GetAllVMs, callInfo)
	mock.lockGetAllVMs.Unlock()
	return mock.GetAllVMsFunc(ctx)
}

// GetAllVMsCalls gets all the calls that were made to GetAllVMs.
// Check the length with:
//
//	len(mockedSource.GetAllVMsCalls())
func (mock *SourceMock) GetAllVMsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAllVMs.RLock()
	calls = mock.calls.GetAllVMs
	mock.lockGetAllVMs.RUnlock()
	return calls
}

// GetName calls GetNameFunc.
func (mock *SourceMock) GetName() string {
	if mock.GetNameFunc == nil {
		panic("SourceMock.GetNameFunc: method is nil but Source.GetName was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetName.Lock()
	mock.calls.GetName = append(mock.calls.GetName, callInfo)
	mock.lockGetName.Unlock()
	return mock.GetNameFunc()
}

// GetNameCalls gets all the calls that were made to GetName.
// Check the length with:
//
//	len(mockedSource.GetNameCalls())
func (mock *SourceMock) GetNameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetName.RLock()
	calls = mock.calls.GetName
	mock.lockGetName.RUnlock()
	return calls
}

// ImportDisks calls ImportDisksFunc.
func (mock *SourceMock) ImportDisks(ctx context.Context, vmName string, statusCallback func(string, bool)) error {
	if mock.ImportDisksFunc == nil {
		panic("SourceMock.ImportDisksFunc: method is nil but Source.ImportDisks was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		VmName         string
		StatusCallback func(string, bool)
	}{
		Ctx:            ctx,
		VmName:         vmName,
		StatusCallback: statusCallback,
	}
	mock.lockImportDisks.Lock()
	mock.calls.ImportDisks = append(mock.calls.ImportDisks, callInfo)
	mock.lockImportDisks.Unlock()
	return mock.ImportDisksFunc(ctx, vmName, statusCallback)
}

// ImportDisksCalls gets all the calls that were made to ImportDisks.
// Check the length with:
//
//	len(mockedSource.ImportDisksCalls())
func (mock *SourceMock) ImportDisksCalls() []struct {
	Ctx            context.Context
	VmName         string
	StatusCallback func(string, bool)
} {
	var calls []struct {
		Ctx            context.Context
		VmName         string
		StatusCallback func(string, bool)
	}
	mock.lockImportDisks.RLock()
	calls = mock.calls.ImportDisks
	mock.lockImportDisks.RUnlock()
	return calls
}

// IsConnected calls IsConnectedFunc.
func (mock *SourceMock) IsConnected() bool {
	if mock.IsConnectedFunc == nil {
		panic("SourceMock.IsConnectedFunc: method is nil but Source.IsConnected was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsConnected.Lock()
	mock.calls.IsConnected = append(mock.calls.IsConnected, callInfo)
	mock.lockIsConnected.Unlock()
	return mock.IsConnectedFunc()
}

// IsConnectedCalls gets all the calls that were made to IsConnected.
// Check the length with:
//
//	len(mockedSource.IsConnectedCalls())
func (mock *SourceMock) IsConnectedCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsConnected.RLock()
	calls = mock.calls.IsConnected
	mock.lockIsConnected.RUnlock()
	return calls
}

// PowerOffVM calls PowerOffVMFunc.
func (mock *SourceMock) PowerOffVM(ctx context.Context, vmName string) error {
	if mock.PowerOffVMFunc == nil {
		panic("SourceMock.PowerOffVMFunc: method is nil but Source.PowerOffVM was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		VmName string
	}{
		Ctx:    ctx,
		VmName: vmName,
	}
	mock.lockPowerOffVM.Lock()
	mock.calls.PowerOffVM = append(mock.calls.PowerOffVM, callInfo)
	mock.lockPowerOffVM.Unlock()
	return mock.PowerOffVMFunc(ctx, vmName)
}

// PowerOffVMCalls gets all the calls that were made to PowerOffVM.
// Check the length with:
//
//	len(mockedSource.PowerOffVMCalls())
func (mock *SourceMock) PowerOffVMCalls() []struct {
	Ctx    context.Context
	VmName string
} {
	var calls []struct {
		Ctx    context.Context
		VmName string
	}
	mock.lockPowerOffVM.RLock()
	calls = mock.calls.PowerOffVM
	mock.lockPowerOffVM.RUnlock()
	return calls
}

// WithAdditionalRootCertificate calls WithAdditionalRootCertificateFunc.
func (mock *SourceMock) WithAdditionalRootCertificate(rootCert *x509.Certificate) {
	if mock.WithAdditionalRootCertificateFunc == nil {
		panic("SourceMock.WithAdditionalRootCertificateFunc: method is nil but Source.WithAdditionalRootCertificate was just called")
	}
	callInfo := struct {
		RootCert *x509.Certificate
	}{
		RootCert: rootCert,
	}
	mock.lockWithAdditionalRootCertificate.Lock()
	mock.calls.WithAdditionalRootCertificate = append(mock.calls.WithAdditionalRootCertificate, callInfo)
	mock.lockWithAdditionalRootCertificate.Unlock()
	mock.WithAdditionalRootCertificateFunc(rootCert)
}

// WithAdditionalRootCertificateCalls gets all the calls that were made to WithAdditionalRootCertificate.
// Check the length with:
//
//	len(mockedSource.WithAdditionalRootCertificateCalls())
func (mock *SourceMock) WithAdditionalRootCertificateCalls() []struct {
	RootCert *x509.Certificate
} {
	var calls []struct {
		RootCert *x509.Certificate
	}
	mock.lockWithAdditionalRootCertificate.RLock()
	calls = mock.calls.WithAdditionalRootCertificate
	mock.lockWithAdditionalRootCertificate.RUnlock()
	return calls
}
