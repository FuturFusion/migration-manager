// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package migration_test

import (
	"context"
	"sync"

	"github.com/FuturFusion/migration-manager/internal/migration"
	"github.com/google/uuid"
)

// Ensure, that InstanceServiceMock does implement migration.InstanceService.
// If this is not the case, regenerate this file with moq.
var _ migration.InstanceService = &InstanceServiceMock{}

// InstanceServiceMock is a mock implementation of migration.InstanceService.
//
//	func TestSomethingThatUsesInstanceService(t *testing.T) {
//
//		// make and configure a mocked migration.InstanceService
//		mockedInstanceService := &InstanceServiceMock{
//			CreateFunc: func(ctx context.Context, instance migration.Instance) (migration.Instance, error) {
//				panic("mock out the Create method")
//			},
//			DeleteByUUIDFunc: func(ctx context.Context, id uuid.UUID) error {
//				panic("mock out the DeleteByUUID method")
//			},
//			GetAllFunc: func(ctx context.Context) (migration.Instances, error) {
//				panic("mock out the GetAll method")
//			},
//			GetAllAssignedFunc: func(ctx context.Context) (migration.Instances, error) {
//				panic("mock out the GetAllAssigned method")
//			},
//			GetAllByBatchFunc: func(ctx context.Context, batch string) (migration.Instances, error) {
//				panic("mock out the GetAllByBatch method")
//			},
//			GetAllBySourceFunc: func(ctx context.Context, source string) (migration.Instances, error) {
//				panic("mock out the GetAllBySource method")
//			},
//			GetAllQueuedFunc: func(ctx context.Context, queue migration.QueueEntries) (migration.Instances, error) {
//				panic("mock out the GetAllQueued method")
//			},
//			GetAllUUIDsFunc: func(ctx context.Context) ([]uuid.UUID, error) {
//				panic("mock out the GetAllUUIDs method")
//			},
//			GetAllUUIDsBySourceFunc: func(ctx context.Context, source string) ([]uuid.UUID, error) {
//				panic("mock out the GetAllUUIDsBySource method")
//			},
//			GetAllUnassignedFunc: func(ctx context.Context) (migration.Instances, error) {
//				panic("mock out the GetAllUnassigned method")
//			},
//			GetBatchesByUUIDFunc: func(ctx context.Context, id uuid.UUID) (migration.Batches, error) {
//				panic("mock out the GetBatchesByUUID method")
//			},
//			GetByUUIDFunc: func(ctx context.Context, id uuid.UUID) (*migration.Instance, error) {
//				panic("mock out the GetByUUID method")
//			},
//			GetPostMigrationRetriesFunc: func(id uuid.UUID) int {
//				panic("mock out the GetPostMigrationRetries method")
//			},
//			RecordPostMigrationRetryFunc: func(id uuid.UUID)  {
//				panic("mock out the RecordPostMigrationRetry method")
//			},
//			RemoveFromQueueFunc: func(ctx context.Context, id uuid.UUID) error {
//				panic("mock out the RemoveFromQueue method")
//			},
//			UpdateFunc: func(ctx context.Context, instance *migration.Instance) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedInstanceService in code that requires migration.InstanceService
//		// and then make assertions.
//
//	}
type InstanceServiceMock struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, instance migration.Instance) (migration.Instance, error)

	// DeleteByUUIDFunc mocks the DeleteByUUID method.
	DeleteByUUIDFunc func(ctx context.Context, id uuid.UUID) error

	// GetAllFunc mocks the GetAll method.
	GetAllFunc func(ctx context.Context) (migration.Instances, error)

	// GetAllAssignedFunc mocks the GetAllAssigned method.
	GetAllAssignedFunc func(ctx context.Context) (migration.Instances, error)

	// GetAllByBatchFunc mocks the GetAllByBatch method.
	GetAllByBatchFunc func(ctx context.Context, batch string) (migration.Instances, error)

	// GetAllBySourceFunc mocks the GetAllBySource method.
	GetAllBySourceFunc func(ctx context.Context, source string) (migration.Instances, error)

	// GetAllQueuedFunc mocks the GetAllQueued method.
	GetAllQueuedFunc func(ctx context.Context, queue migration.QueueEntries) (migration.Instances, error)

	// GetAllUUIDsFunc mocks the GetAllUUIDs method.
	GetAllUUIDsFunc func(ctx context.Context) ([]uuid.UUID, error)

	// GetAllUUIDsBySourceFunc mocks the GetAllUUIDsBySource method.
	GetAllUUIDsBySourceFunc func(ctx context.Context, source string) ([]uuid.UUID, error)

	// GetAllUnassignedFunc mocks the GetAllUnassigned method.
	GetAllUnassignedFunc func(ctx context.Context) (migration.Instances, error)

	// GetBatchesByUUIDFunc mocks the GetBatchesByUUID method.
	GetBatchesByUUIDFunc func(ctx context.Context, id uuid.UUID) (migration.Batches, error)

	// GetByUUIDFunc mocks the GetByUUID method.
	GetByUUIDFunc func(ctx context.Context, id uuid.UUID) (*migration.Instance, error)

	// GetPostMigrationRetriesFunc mocks the GetPostMigrationRetries method.
	GetPostMigrationRetriesFunc func(id uuid.UUID) int

	// RecordPostMigrationRetryFunc mocks the RecordPostMigrationRetry method.
	RecordPostMigrationRetryFunc func(id uuid.UUID)

	// RemoveFromQueueFunc mocks the RemoveFromQueue method.
	RemoveFromQueueFunc func(ctx context.Context, id uuid.UUID) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, instance *migration.Instance) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Instance is the instance argument value.
			Instance migration.Instance
		}
		// DeleteByUUID holds details about calls to the DeleteByUUID method.
		DeleteByUUID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetAll holds details about calls to the GetAll method.
		GetAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetAllAssigned holds details about calls to the GetAllAssigned method.
		GetAllAssigned []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetAllByBatch holds details about calls to the GetAllByBatch method.
		GetAllByBatch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Batch is the batch argument value.
			Batch string
		}
		// GetAllBySource holds details about calls to the GetAllBySource method.
		GetAllBySource []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Source is the source argument value.
			Source string
		}
		// GetAllQueued holds details about calls to the GetAllQueued method.
		GetAllQueued []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Queue is the queue argument value.
			Queue migration.QueueEntries
		}
		// GetAllUUIDs holds details about calls to the GetAllUUIDs method.
		GetAllUUIDs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetAllUUIDsBySource holds details about calls to the GetAllUUIDsBySource method.
		GetAllUUIDsBySource []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Source is the source argument value.
			Source string
		}
		// GetAllUnassigned holds details about calls to the GetAllUnassigned method.
		GetAllUnassigned []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetBatchesByUUID holds details about calls to the GetBatchesByUUID method.
		GetBatchesByUUID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetByUUID holds details about calls to the GetByUUID method.
		GetByUUID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetPostMigrationRetries holds details about calls to the GetPostMigrationRetries method.
		GetPostMigrationRetries []struct {
			// ID is the id argument value.
			ID uuid.UUID
		}
		// RecordPostMigrationRetry holds details about calls to the RecordPostMigrationRetry method.
		RecordPostMigrationRetry []struct {
			// ID is the id argument value.
			ID uuid.UUID
		}
		// RemoveFromQueue holds details about calls to the RemoveFromQueue method.
		RemoveFromQueue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Instance is the instance argument value.
			Instance *migration.Instance
		}
	}
	lockCreate                   sync.RWMutex
	lockDeleteByUUID             sync.RWMutex
	lockGetAll                   sync.RWMutex
	lockGetAllAssigned           sync.RWMutex
	lockGetAllByBatch            sync.RWMutex
	lockGetAllBySource           sync.RWMutex
	lockGetAllQueued             sync.RWMutex
	lockGetAllUUIDs              sync.RWMutex
	lockGetAllUUIDsBySource      sync.RWMutex
	lockGetAllUnassigned         sync.RWMutex
	lockGetBatchesByUUID         sync.RWMutex
	lockGetByUUID                sync.RWMutex
	lockGetPostMigrationRetries  sync.RWMutex
	lockRecordPostMigrationRetry sync.RWMutex
	lockRemoveFromQueue          sync.RWMutex
	lockUpdate                   sync.RWMutex
}

// Create calls CreateFunc.
func (mock *InstanceServiceMock) Create(ctx context.Context, instance migration.Instance) (migration.Instance, error) {
	if mock.CreateFunc == nil {
		panic("InstanceServiceMock.CreateFunc: method is nil but InstanceService.Create was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Instance migration.Instance
	}{
		Ctx:      ctx,
		Instance: instance,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, instance)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedInstanceService.CreateCalls())
func (mock *InstanceServiceMock) CreateCalls() []struct {
	Ctx      context.Context
	Instance migration.Instance
} {
	var calls []struct {
		Ctx      context.Context
		Instance migration.Instance
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// DeleteByUUID calls DeleteByUUIDFunc.
func (mock *InstanceServiceMock) DeleteByUUID(ctx context.Context, id uuid.UUID) error {
	if mock.DeleteByUUIDFunc == nil {
		panic("InstanceServiceMock.DeleteByUUIDFunc: method is nil but InstanceService.DeleteByUUID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteByUUID.Lock()
	mock.calls.DeleteByUUID = append(mock.calls.DeleteByUUID, callInfo)
	mock.lockDeleteByUUID.Unlock()
	return mock.DeleteByUUIDFunc(ctx, id)
}

// DeleteByUUIDCalls gets all the calls that were made to DeleteByUUID.
// Check the length with:
//
//	len(mockedInstanceService.DeleteByUUIDCalls())
func (mock *InstanceServiceMock) DeleteByUUIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockDeleteByUUID.RLock()
	calls = mock.calls.DeleteByUUID
	mock.lockDeleteByUUID.RUnlock()
	return calls
}

// GetAll calls GetAllFunc.
func (mock *InstanceServiceMock) GetAll(ctx context.Context) (migration.Instances, error) {
	if mock.GetAllFunc == nil {
		panic("InstanceServiceMock.GetAllFunc: method is nil but InstanceService.GetAll was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAll.Lock()
	mock.calls.GetAll = append(mock.calls.GetAll, callInfo)
	mock.lockGetAll.Unlock()
	return mock.GetAllFunc(ctx)
}

// GetAllCalls gets all the calls that were made to GetAll.
// Check the length with:
//
//	len(mockedInstanceService.GetAllCalls())
func (mock *InstanceServiceMock) GetAllCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAll.RLock()
	calls = mock.calls.GetAll
	mock.lockGetAll.RUnlock()
	return calls
}

// GetAllAssigned calls GetAllAssignedFunc.
func (mock *InstanceServiceMock) GetAllAssigned(ctx context.Context) (migration.Instances, error) {
	if mock.GetAllAssignedFunc == nil {
		panic("InstanceServiceMock.GetAllAssignedFunc: method is nil but InstanceService.GetAllAssigned was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAllAssigned.Lock()
	mock.calls.GetAllAssigned = append(mock.calls.GetAllAssigned, callInfo)
	mock.lockGetAllAssigned.Unlock()
	return mock.GetAllAssignedFunc(ctx)
}

// GetAllAssignedCalls gets all the calls that were made to GetAllAssigned.
// Check the length with:
//
//	len(mockedInstanceService.GetAllAssignedCalls())
func (mock *InstanceServiceMock) GetAllAssignedCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAllAssigned.RLock()
	calls = mock.calls.GetAllAssigned
	mock.lockGetAllAssigned.RUnlock()
	return calls
}

// GetAllByBatch calls GetAllByBatchFunc.
func (mock *InstanceServiceMock) GetAllByBatch(ctx context.Context, batch string) (migration.Instances, error) {
	if mock.GetAllByBatchFunc == nil {
		panic("InstanceServiceMock.GetAllByBatchFunc: method is nil but InstanceService.GetAllByBatch was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Batch string
	}{
		Ctx:   ctx,
		Batch: batch,
	}
	mock.lockGetAllByBatch.Lock()
	mock.calls.GetAllByBatch = append(mock.calls.GetAllByBatch, callInfo)
	mock.lockGetAllByBatch.Unlock()
	return mock.GetAllByBatchFunc(ctx, batch)
}

// GetAllByBatchCalls gets all the calls that were made to GetAllByBatch.
// Check the length with:
//
//	len(mockedInstanceService.GetAllByBatchCalls())
func (mock *InstanceServiceMock) GetAllByBatchCalls() []struct {
	Ctx   context.Context
	Batch string
} {
	var calls []struct {
		Ctx   context.Context
		Batch string
	}
	mock.lockGetAllByBatch.RLock()
	calls = mock.calls.GetAllByBatch
	mock.lockGetAllByBatch.RUnlock()
	return calls
}

// GetAllBySource calls GetAllBySourceFunc.
func (mock *InstanceServiceMock) GetAllBySource(ctx context.Context, source string) (migration.Instances, error) {
	if mock.GetAllBySourceFunc == nil {
		panic("InstanceServiceMock.GetAllBySourceFunc: method is nil but InstanceService.GetAllBySource was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Source string
	}{
		Ctx:    ctx,
		Source: source,
	}
	mock.lockGetAllBySource.Lock()
	mock.calls.GetAllBySource = append(mock.calls.GetAllBySource, callInfo)
	mock.lockGetAllBySource.Unlock()
	return mock.GetAllBySourceFunc(ctx, source)
}

// GetAllBySourceCalls gets all the calls that were made to GetAllBySource.
// Check the length with:
//
//	len(mockedInstanceService.GetAllBySourceCalls())
func (mock *InstanceServiceMock) GetAllBySourceCalls() []struct {
	Ctx    context.Context
	Source string
} {
	var calls []struct {
		Ctx    context.Context
		Source string
	}
	mock.lockGetAllBySource.RLock()
	calls = mock.calls.GetAllBySource
	mock.lockGetAllBySource.RUnlock()
	return calls
}

// GetAllQueued calls GetAllQueuedFunc.
func (mock *InstanceServiceMock) GetAllQueued(ctx context.Context, queue migration.QueueEntries) (migration.Instances, error) {
	if mock.GetAllQueuedFunc == nil {
		panic("InstanceServiceMock.GetAllQueuedFunc: method is nil but InstanceService.GetAllQueued was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Queue migration.QueueEntries
	}{
		Ctx:   ctx,
		Queue: queue,
	}
	mock.lockGetAllQueued.Lock()
	mock.calls.GetAllQueued = append(mock.calls.GetAllQueued, callInfo)
	mock.lockGetAllQueued.Unlock()
	return mock.GetAllQueuedFunc(ctx, queue)
}

// GetAllQueuedCalls gets all the calls that were made to GetAllQueued.
// Check the length with:
//
//	len(mockedInstanceService.GetAllQueuedCalls())
func (mock *InstanceServiceMock) GetAllQueuedCalls() []struct {
	Ctx   context.Context
	Queue migration.QueueEntries
} {
	var calls []struct {
		Ctx   context.Context
		Queue migration.QueueEntries
	}
	mock.lockGetAllQueued.RLock()
	calls = mock.calls.GetAllQueued
	mock.lockGetAllQueued.RUnlock()
	return calls
}

// GetAllUUIDs calls GetAllUUIDsFunc.
func (mock *InstanceServiceMock) GetAllUUIDs(ctx context.Context) ([]uuid.UUID, error) {
	if mock.GetAllUUIDsFunc == nil {
		panic("InstanceServiceMock.GetAllUUIDsFunc: method is nil but InstanceService.GetAllUUIDs was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAllUUIDs.Lock()
	mock.calls.GetAllUUIDs = append(mock.calls.GetAllUUIDs, callInfo)
	mock.lockGetAllUUIDs.Unlock()
	return mock.GetAllUUIDsFunc(ctx)
}

// GetAllUUIDsCalls gets all the calls that were made to GetAllUUIDs.
// Check the length with:
//
//	len(mockedInstanceService.GetAllUUIDsCalls())
func (mock *InstanceServiceMock) GetAllUUIDsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAllUUIDs.RLock()
	calls = mock.calls.GetAllUUIDs
	mock.lockGetAllUUIDs.RUnlock()
	return calls
}

// GetAllUUIDsBySource calls GetAllUUIDsBySourceFunc.
func (mock *InstanceServiceMock) GetAllUUIDsBySource(ctx context.Context, source string) ([]uuid.UUID, error) {
	if mock.GetAllUUIDsBySourceFunc == nil {
		panic("InstanceServiceMock.GetAllUUIDsBySourceFunc: method is nil but InstanceService.GetAllUUIDsBySource was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Source string
	}{
		Ctx:    ctx,
		Source: source,
	}
	mock.lockGetAllUUIDsBySource.Lock()
	mock.calls.GetAllUUIDsBySource = append(mock.calls.GetAllUUIDsBySource, callInfo)
	mock.lockGetAllUUIDsBySource.Unlock()
	return mock.GetAllUUIDsBySourceFunc(ctx, source)
}

// GetAllUUIDsBySourceCalls gets all the calls that were made to GetAllUUIDsBySource.
// Check the length with:
//
//	len(mockedInstanceService.GetAllUUIDsBySourceCalls())
func (mock *InstanceServiceMock) GetAllUUIDsBySourceCalls() []struct {
	Ctx    context.Context
	Source string
} {
	var calls []struct {
		Ctx    context.Context
		Source string
	}
	mock.lockGetAllUUIDsBySource.RLock()
	calls = mock.calls.GetAllUUIDsBySource
	mock.lockGetAllUUIDsBySource.RUnlock()
	return calls
}

// GetAllUnassigned calls GetAllUnassignedFunc.
func (mock *InstanceServiceMock) GetAllUnassigned(ctx context.Context) (migration.Instances, error) {
	if mock.GetAllUnassignedFunc == nil {
		panic("InstanceServiceMock.GetAllUnassignedFunc: method is nil but InstanceService.GetAllUnassigned was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAllUnassigned.Lock()
	mock.calls.GetAllUnassigned = append(mock.calls.GetAllUnassigned, callInfo)
	mock.lockGetAllUnassigned.Unlock()
	return mock.GetAllUnassignedFunc(ctx)
}

// GetAllUnassignedCalls gets all the calls that were made to GetAllUnassigned.
// Check the length with:
//
//	len(mockedInstanceService.GetAllUnassignedCalls())
func (mock *InstanceServiceMock) GetAllUnassignedCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAllUnassigned.RLock()
	calls = mock.calls.GetAllUnassigned
	mock.lockGetAllUnassigned.RUnlock()
	return calls
}

// GetBatchesByUUID calls GetBatchesByUUIDFunc.
func (mock *InstanceServiceMock) GetBatchesByUUID(ctx context.Context, id uuid.UUID) (migration.Batches, error) {
	if mock.GetBatchesByUUIDFunc == nil {
		panic("InstanceServiceMock.GetBatchesByUUIDFunc: method is nil but InstanceService.GetBatchesByUUID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetBatchesByUUID.Lock()
	mock.calls.GetBatchesByUUID = append(mock.calls.GetBatchesByUUID, callInfo)
	mock.lockGetBatchesByUUID.Unlock()
	return mock.GetBatchesByUUIDFunc(ctx, id)
}

// GetBatchesByUUIDCalls gets all the calls that were made to GetBatchesByUUID.
// Check the length with:
//
//	len(mockedInstanceService.GetBatchesByUUIDCalls())
func (mock *InstanceServiceMock) GetBatchesByUUIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockGetBatchesByUUID.RLock()
	calls = mock.calls.GetBatchesByUUID
	mock.lockGetBatchesByUUID.RUnlock()
	return calls
}

// GetByUUID calls GetByUUIDFunc.
func (mock *InstanceServiceMock) GetByUUID(ctx context.Context, id uuid.UUID) (*migration.Instance, error) {
	if mock.GetByUUIDFunc == nil {
		panic("InstanceServiceMock.GetByUUIDFunc: method is nil but InstanceService.GetByUUID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetByUUID.Lock()
	mock.calls.GetByUUID = append(mock.calls.GetByUUID, callInfo)
	mock.lockGetByUUID.Unlock()
	return mock.GetByUUIDFunc(ctx, id)
}

// GetByUUIDCalls gets all the calls that were made to GetByUUID.
// Check the length with:
//
//	len(mockedInstanceService.GetByUUIDCalls())
func (mock *InstanceServiceMock) GetByUUIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockGetByUUID.RLock()
	calls = mock.calls.GetByUUID
	mock.lockGetByUUID.RUnlock()
	return calls
}

// GetPostMigrationRetries calls GetPostMigrationRetriesFunc.
func (mock *InstanceServiceMock) GetPostMigrationRetries(id uuid.UUID) int {
	if mock.GetPostMigrationRetriesFunc == nil {
		panic("InstanceServiceMock.GetPostMigrationRetriesFunc: method is nil but InstanceService.GetPostMigrationRetries was just called")
	}
	callInfo := struct {
		ID uuid.UUID
	}{
		ID: id,
	}
	mock.lockGetPostMigrationRetries.Lock()
	mock.calls.GetPostMigrationRetries = append(mock.calls.GetPostMigrationRetries, callInfo)
	mock.lockGetPostMigrationRetries.Unlock()
	return mock.GetPostMigrationRetriesFunc(id)
}

// GetPostMigrationRetriesCalls gets all the calls that were made to GetPostMigrationRetries.
// Check the length with:
//
//	len(mockedInstanceService.GetPostMigrationRetriesCalls())
func (mock *InstanceServiceMock) GetPostMigrationRetriesCalls() []struct {
	ID uuid.UUID
} {
	var calls []struct {
		ID uuid.UUID
	}
	mock.lockGetPostMigrationRetries.RLock()
	calls = mock.calls.GetPostMigrationRetries
	mock.lockGetPostMigrationRetries.RUnlock()
	return calls
}

// RecordPostMigrationRetry calls RecordPostMigrationRetryFunc.
func (mock *InstanceServiceMock) RecordPostMigrationRetry(id uuid.UUID) {
	if mock.RecordPostMigrationRetryFunc == nil {
		panic("InstanceServiceMock.RecordPostMigrationRetryFunc: method is nil but InstanceService.RecordPostMigrationRetry was just called")
	}
	callInfo := struct {
		ID uuid.UUID
	}{
		ID: id,
	}
	mock.lockRecordPostMigrationRetry.Lock()
	mock.calls.RecordPostMigrationRetry = append(mock.calls.RecordPostMigrationRetry, callInfo)
	mock.lockRecordPostMigrationRetry.Unlock()
	mock.RecordPostMigrationRetryFunc(id)
}

// RecordPostMigrationRetryCalls gets all the calls that were made to RecordPostMigrationRetry.
// Check the length with:
//
//	len(mockedInstanceService.RecordPostMigrationRetryCalls())
func (mock *InstanceServiceMock) RecordPostMigrationRetryCalls() []struct {
	ID uuid.UUID
} {
	var calls []struct {
		ID uuid.UUID
	}
	mock.lockRecordPostMigrationRetry.RLock()
	calls = mock.calls.RecordPostMigrationRetry
	mock.lockRecordPostMigrationRetry.RUnlock()
	return calls
}

// RemoveFromQueue calls RemoveFromQueueFunc.
func (mock *InstanceServiceMock) RemoveFromQueue(ctx context.Context, id uuid.UUID) error {
	if mock.RemoveFromQueueFunc == nil {
		panic("InstanceServiceMock.RemoveFromQueueFunc: method is nil but InstanceService.RemoveFromQueue was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockRemoveFromQueue.Lock()
	mock.calls.RemoveFromQueue = append(mock.calls.RemoveFromQueue, callInfo)
	mock.lockRemoveFromQueue.Unlock()
	return mock.RemoveFromQueueFunc(ctx, id)
}

// RemoveFromQueueCalls gets all the calls that were made to RemoveFromQueue.
// Check the length with:
//
//	len(mockedInstanceService.RemoveFromQueueCalls())
func (mock *InstanceServiceMock) RemoveFromQueueCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockRemoveFromQueue.RLock()
	calls = mock.calls.RemoveFromQueue
	mock.lockRemoveFromQueue.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *InstanceServiceMock) Update(ctx context.Context, instance *migration.Instance) error {
	if mock.UpdateFunc == nil {
		panic("InstanceServiceMock.UpdateFunc: method is nil but InstanceService.Update was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Instance *migration.Instance
	}{
		Ctx:      ctx,
		Instance: instance,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, instance)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedInstanceService.UpdateCalls())
func (mock *InstanceServiceMock) UpdateCalls() []struct {
	Ctx      context.Context
	Instance *migration.Instance
} {
	var calls []struct {
		Ctx      context.Context
		Instance *migration.Instance
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}
